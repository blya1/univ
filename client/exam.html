<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Помощник для экзамена</title>
    <link rel="stylesheet" href="/style.css">
</head>

<body>
    <div class="container" id="auth-check">
        <div id="not-authorized" style="display: none;">
            <h2>Требуется авторизация</h2>
            <p>Пожалуйста, войдите для доступа к помощнику.</p>
            <button onclick="window.location.href='/'">Войти</button>
        </div>
        <div id="authorized" style="display: none;">
            <h2>Помощник для экзамена</h2>
            <div id="clients"></div>
            <button onclick="logout()">Выйти</button>
        </div>
        <div id="disconnected-message">Пользователь отключился</div>
    </div>
    <script>
<<<<<<< HEAD
        let ws = new WebSocket('ws://localhost:8080');
        let isAuthorized = false;
        let pendingMessages = [];
=======
        (async () => {
            let socket = new WebSocket('ws://' + window.location.host);
            let currentToken = localStorage.getItem('authToken') || '';
>>>>>>> 0aa341a35d81d7b4cb581b2dbbe6ccf2d9ea9c07

        ws.onopen = () => {
            console.log('exam.html: WebSocket connected');
            const token = localStorage.getItem('authToken');
            if (token) {
                ws.send(JSON.stringify({ type: 'verifyToken', token }));
            } else {
                showNotAuthorized();
            }
            ws.send(JSON.stringify({ role: 'exam' }));
        };

        ws.onmessage = (event) => {
            try {
                const response = JSON.parse(event.data);
                console.log('exam.html: Received message:', response);

                if (response.type === 'verifyTokenResponse') {
                    if (response.success) {
                        isAuthorized = true;
                        document.getElementById('authorized').style.display = 'block';
                        document.getElementById('not-authorized').style.display = 'none';
                        pendingMessages.forEach(msg => processMessage(msg));
                        pendingMessages = [];
                    } else {
                        showNotAuthorized();
                    }
                } else if (isAuthorized) {
                    processMessage(response);
                } else {
                    console.log('exam.html: Buffering message until authorized:', response);
                    pendingMessages.push(response);
                }
            } catch (error) {
                console.error('exam.html: Error parsing message:', error);
            }
        };

        ws.onerror = (error) => {
            console.error('exam.html: WebSocket error:', error);
        };

        ws.onclose = () => {
            console.log('exam.html: WebSocket closed, attempting reconnect in 5s');
            setTimeout(() => {
                ws = new WebSocket('ws://localhost:8080');
                ws.onopen = () => {
                    console.log('exam.html: WebSocket reconnected');
                    const token = localStorage.getItem('authToken');
                    if (token) {
                        ws.send(JSON.stringify({ type: 'verifyToken', token }));
                    }
                    ws.send(JSON.stringify({ role: 'exam' }));
                };
            }, 5000);
        };

        function processMessage(response) {
            console.log('exam.html: Processing message:', response);
            if (response.type === 'initialState') {
                console.log('exam.html: Processing initialState:', response.screenshots);
                updateClients(response.screenshots);
            } else if (response.type === 'screenshot') {
                console.log('exam.html: Processing screenshot:', response);
                addScreenshot(response.clientId, response);
            } else if (response.type === 'answer') {
                updateAnswer(response.clientId, response);
            } else if (response.type === 'clientDisconnected') {
                showDisconnectedMessage(response.clientId);
            }
        }

        function showNotAuthorized() {
            document.getElementById('not-authorized').style.display = 'block';
            document.getElementById('authorized').style.display = 'none';
            setTimeout(() => {
                window.location.href = '/';
            }, 2000);
        }

        function logout() {
            const token = localStorage.getItem('authToken');
            if (token) {
                ws.send(JSON.stringify({ type: 'logout', token }));
            }
            localStorage.removeItem('authToken');
            window.location.href = '/';
        }

        function updateClients(screenshots) {
            console.log('exam.html: Updating clients with screenshots:', screenshots);
            const clientsDiv = document.getElementById('clients');
            clientsDiv.innerHTML = '';
            const clientMap = new Map();

            screenshots.forEach(s => {
                if (!clientMap.has(s.clientId)) {
                    clientMap.set(s.clientId, []);
                }
<<<<<<< HEAD
                clientMap.get(s.clientId).push(s);
=======
            };

            ws.onmessage = (event) => {
                try {
                    const response = JSON.parse(event.data);
                    console.log('exam.html: Received message:', response);

                    if (response.type === 'verifyTokenResponse') {
                        if (response.success) {
                            isAuthorized = true;
                            document.getElementById('authorized').style.display = 'block';
                            document.getElementById('not-authorized').style.display = 'none';
                            pendingMessages.forEach(msg => processMessage(msg));
                            pendingMessages = [];
                        } else {
                            showNotAuthorized();
                        }
                    } else if (isAuthorized) {
                        processMessage(response);
                    } else {
                        console.log('exam.html: Buffering message until authorized:', response);
                        pendingMessages.push(response);
                    }
                } catch (error) {
                    console.error('exam.html: Error parsing message:', error);
                }
            };

            ws.onerror = (error) => {
                console.error('exam.html: WebSocket error:', error);
            };

            socket.onclose = () => {
                console.log('exam.js: WebSocket closed, attempting reconnect in 5s');
                setTimeout(() => {
                    socket = new WebSocket('ws://' + window.location.host);
                    socket.onopen = () => {
                        console.log('exam.js: WebSocket reconnected');
                        if (currentToken) {
                            socket.send(JSON.stringify({ type: 'verifyToken', token: currentToken }));
                        } else {
                            socket.send(JSON.stringify({ role: 'exam' }));
                        }
                    };
                    socket.onmessage = socket.onmessage;
                    socket.onerror = socket.onerror;
                    socket.onclose = socket.onclose;
                }, 5000);
            };

            loginBtn.addEventListener('click', () => {
                const username = usernameInput.value;
                const password = passwordInput.value;
                socket.send(JSON.stringify({ type: 'login', username, password }));
            });

            logoutBtn.addEventListener('click', () => {
                localStorage.removeItem('authToken');
                currentToken = '';
                loginSection.style.display = 'block';
                examSection.style.display = 'none';
                authCheck.style.display = 'none';
                authMessage.textContent = '';
                usernameInput.value = '';
                passwordInput.value = '';
            });

            function updateClients(screenshots) {
                const clientsDiv = document.getElementById('clients');
                clientsDiv.innerHTML = '';

                const clientsMap = new Map();
                screenshots.forEach(screenshot => {
                    if (!clientsMap.has(screenshot.clientId)) {
                        clientsMap.set(screenshot.clientId, []);
                    }
                    clientsMap.get(screenshot.clientId).push(screenshot);
                });

                clientsMap.forEach((screenshots, clientId) => {
                    const clientSection = document.createElement('div');
                    clientSection.className = 'client-section';
                    clientSection.dataset.clientId = clientId;

                    const clientHeader = document.createElement('div');
                    clientHeader.className = 'client-header';
                    clientHeader.innerHTML = `<button>Клиент ${clientId}</button>`;
                    clientSection.appendChild(clientHeader);

                    const questionsDiv = document.createElement('div');
                    questionsDiv.className = 'questions';
                    screenshots.forEach(screenshot => {
                        const questionDiv = document.createElement('div');
                        questionDiv.className = 'question';
                        questionDiv.dataset.questionId = screenshot.questionId;
                        questionDiv.innerHTML = `
                            <img src="${screenshot.screenshot}" alt="Скриншот">
                            <div class="answer-input">
                                <input type="text" placeholder="Введите ответ" data-question-id="${screenshot.questionId}">
                                <button>Отправить</button>
                            </div>
                            <p class="answer-text" style="display: none;"></p>
                        `;
                        questionsDiv.appendChild(questionDiv);
                    });

                    clientSection.appendChild(questionsDiv);
                    clientsDiv.appendChild(clientSection);

                    const button = clientHeader.querySelector('button');
                    button.addEventListener('click', () => {
                        questionsDiv.style.display = questionsDiv.style.display === 'block' ? 'none' : 'block';
                    });

                    questionsDiv.querySelectorAll('.answer-input button').forEach(button => {
                        button.addEventListener('click', () => {
                            const input = button.previousElementSibling;
                            const answer = input.value;
                            const questionId = input.dataset.questionId;
                            if (answer && socket.readyState === WebSocket.OPEN) {
                                socket.send(JSON.stringify({
                                    type: 'answer',
                                    questionId,
                                    answer,
                                    clientId,
                                    answeredBy: usernameInput.value || 'Аноним'
                                }));
                            }
                        });
                    });
                });
            }

            function addScreenshot(screenshot) {
                let clientSection = document.querySelector(`.client-section[data-client-id="${screenshot.clientId}"]`);
                if (!clientSection) {
                    clientSection = document.createElement('div');
                    clientSection.className = 'client-section';
                    clientSection.dataset.clientId = screenshot.clientId;
                    clientSection.innerHTML = `<div class="client-header"><button>Клиент ${screenshot.clientId}</button></div><div class="questions"></div>`;
                    document.getElementById('clients').appendChild(clientSection);

                    const button = clientSection.querySelector('button');
                    const questionsDiv = clientSection.querySelector('.questions');
                    button.addEventListener('click', () => {
                        questionsDiv.style.display = questionsDiv.style.display === 'block' ? 'none' : 'block';
                    });
                }

                const questionsDiv = clientSection.querySelector('.questions');
                const existingQuestion = questionsDiv.querySelector(`.question[data-question-id="${screenshot.questionId}"]`);
                if (!existingQuestion) {
                    const questionDiv = document.createElement('div');
                    questionDiv.className = 'question';
                    questionDiv.dataset.questionId = screenshot.questionId;
                    questionDiv.innerHTML = `
                        <img src="${screenshot.screenshot}" alt="Скриншот">
                        <div class="answer-input">
                            <input type="text" placeholder="Введите ответ" data-question-id="${screenshot.questionId}">
                            <button>Отправить</button>
                        </div>
                        <p class="answer-text" style="display: none;"></p>
                    `;
                    questionsDiv.appendChild(questionDiv);

                    const button = questionDiv.querySelector('.answer-input button');
                    button.addEventListener('click', () => {
                        const input = button.previousElementSibling;
                        const answer = input.value;
                        const questionId = input.dataset.questionId;
                        if (answer && socket.readyState === WebSocket.OPEN) {
                            socket.send(JSON.stringify({
                                type: 'answer',
                                questionId,
                                answer,
                                clientId: screenshot.clientId,
                                answeredBy: usernameInput.value || 'Аноним'
                            }));
                        }
                    });
                }
            }

            function updateAnswer(data) {
                const questionDiv = document.querySelector(`.question[data-question-id="${data.questionId}"]`);
                if (questionDiv) {
                    const answerText = questionDiv.querySelector('.answer-text');
                    answerText.textContent = `Ответ от ${data.answeredBy}: ${data.answer}`;
                    answerText.style.display = 'block';
                    const input = questionDiv.querySelector('.answer-input input');
                    input.value = data.answer;
                }
            }

            function removeClient(clientId) {
                const clientSection = document.querySelector(`.client-section[data-client-id="${clientId}"]`);
                if (clientSection) {
                    clientSection.remove();
                }
            }
        })();
    </script>
</body>

</html>